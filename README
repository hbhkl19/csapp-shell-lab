# Shell Lab README

## 项目简介

本项目实现了一个具备作业控制功能的简单 Shell 程序，支持前台和后台作业管理，内建命令 `jobs`、`fg`、`bg` 和 `quit`。通过对信号的捕捉与转发，实现了对子进程的有效管理，保证了前台作业能正确接收用户产生的中断（SIGINT）和停止（SIGTSTP）信号。此外，实现了命令行解析，支持带 `&` 的后台命令。

---

## 开发环境

- 操作系统：Windows Subsystem for Linux (WSL)  
- 编辑器：Visual Studio Code  
- 编译器：gcc（版本随系统环境而定）  

---

## 编译与运行

使用实验手册中提供的 `Makefile` 进行编译：

```bash
make

## 主要功能实现

### 命令解析与执行

- 解析输入的命令行，分割成命令和参数  
- 支持识别后台执行标志 `&`  
- 使用 `fork()` 和 `execve()` 启动子进程执行命令  

### 作业管理

- 维护作业列表，跟踪每个作业的 PID、状态（前台、后台、停止）和命令行  
- 支持内建命令 `jobs` 显示所有作业状态  
- 支持 `fg` 和 `bg` 命令管理作业状态  

### 信号处理与转发

- 捕捉 `SIGCHLD` 信号，及时回收终止或停止的子进程  
- 捕捉 `SIGINT` 和 `SIGTSTP`，将信号转发给前台作业进程组，实现用户通过 Ctrl-C 和 Ctrl-Z 控制作业  
- 通过信号屏蔽和 `sigsuspend` 实现安全的等待机制，避免竞态条件  

### 进程组管理

- 在子进程中调用 `setpgid(0, 0)`，为每个子进程创建新的进程组，避免进程组混乱  
- 保证信号能正确发送到前台进程组，实现作业控制  

---

## 关键实现细节

1. **使用 `sigsuspend` 替代忙等待**

   官方文档推荐 `waitfg` 函数用 `while` 循环加 `sleep` 实现等待，但此方法效率低。  
   
   我选择用更高效的 `sigsuspend`，它能原子地解除信号屏蔽并挂起进程，直到信号到来。  

   因此，需要对 `eval` 函数做如下修改：  
   - 在调用 `addjob` 后，不立即解除对 `SIGCHLD` 的屏蔽。  
   - 在 `waitfg` 中调用 `sigsuspend` 时，`SIGCHLD` 仍被阻塞，`sigsuspend` 临时解除阻塞并等待信号。  
   - 这样避免了在 `sigsuspend` 之前解除屏蔽导致的竞态问题（信号丢失）。  

2. **子进程和父进程区分（进程组设置）**

   在 `fork` 后，子进程必须调用 `setpgid(0, 0)`，将自己放入新的进程组。  

   否则，子进程与父进程处于同一进程组，会破坏 shell 自身的信号处理和作业控制机制，导致信号转发异常。

---

## 遇到的问题及解决方案

- **信号竞态问题**  
  初期 `waitfg` 使用忙等待导致 CPU 占用高，改用 `sigsuspend` 实现高效等待，并调整信号屏蔽顺序解决信号丢失问题。  

- **进程组管理不当**  
  未给子进程设置独立进程组时，导致信号不能正确转发。通过在子进程调用 `setpgid` 解决。  

- **后台作业状态识别错误**  
  解析命令时 `&` 标志识别不准确，导致后台作业被误认为前台作业，修正了解析逻辑。  

---

## 测试结果

- 使用实验提供的测试脚本 `sdriver.pl` 进行验证，所有测试均通过。  
- 覆盖场景包括：  
  - 前台与后台命令执行  
  - 作业列表和状态显示  
  - 信号转发测试（Ctrl-C 和 Ctrl-Z）  
  - 内建命令功能测试  
